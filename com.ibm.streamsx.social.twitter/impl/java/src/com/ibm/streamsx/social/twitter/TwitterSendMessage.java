/* Copyright (C) 2016, International Business Machines Corporation  */
/* All Rights Reserved                                	            */

/* Generated by Streams Studio: February 10, 2016 at 5:55:11 PM GMT+1 */
package com.ibm.streamsx.social.twitter;

import java.io.File;
import java.io.FileReader;
import java.util.Properties;
import org.apache.log4j.Logger;

import com.ibm.streams.operator.AbstractOperator;
import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.model.Libraries;
import com.ibm.streams.operator.model.Parameter;
import com.ibm.streams.operator.model.PrimitiveOperator;
import com.ibm.streams.operator.StreamingData.Punctuation;
import com.ibm.streams.operator.StreamingInput;
import com.ibm.streams.operator.Tuple;
import com.ibm.streams.operator.model.InputPortSet;
import com.ibm.streams.operator.model.InputPortSet.WindowMode;
import com.ibm.streams.operator.model.InputPortSet.WindowPunctuationInputMode;
import com.ibm.streams.operator.model.InputPorts;

/**
 * Class for an operator that receives a tuple and then optionally submits a
 * tuple. This pattern supports one or more input streams and one or more output
 * streams.
 * <P>
 * The following event methods from the Operator interface can be called:
 * </p>
 * <ul>
 * <li><code>initialize()</code> to perform operator initialization</li>
 * <li>allPortsReady() notification indicates the operator's ports are ready to
 * process and submit tuples</li>
 * <li>process() handles a tuple arriving on an input port
 * <li>processPuncuation() handles a punctuation mark arriving on an input port
 * <li>shutdown() to shutdown the operator. A shutdown request may occur at any
 * time, such as a request to stop a PE or cancel a job. Thus the shutdown() may
 * occur while the operator is processing tuples, punctuation marks, or even
 * during port ready notification.</li>
 * </ul>
 * <p>
 * With the exception of operator initialization, all the other events may occur
 * concurrently with each other, which lead to these methods being called
 * concurrently by different threads.
 * </p>
 */
@PrimitiveOperator(name = "TwitterSendMessage", namespace = "com.ibm.streamsx.social.twitter", description = "Java Operator TwitterSendMessage")

@InputPorts({
		@InputPortSet(description = "InputPort that ingests Twitter recipient name and twitter message ", cardinality = 1, optional = false, windowingMode = WindowMode.NonWindowed, windowPunctuationInputMode = WindowPunctuationInputMode.Oblivious) })
@Libraries({ "lib/twitter4j-core-4.0.4.jar" })

public class TwitterSendMessage extends AbstractOperator
{

	protected Properties properties = new Properties(), twitterAuthProperties = new Properties();
	protected String propertiesFile = null;
	protected String consumerKey = null;
	protected String consumerSecret = null;
	protected String accessToken = null;
	protected String accessTokenSecret = null;

	private SendDirectMessage sendDirectMessage;

	/**
	 * Initialize this operator. Called once before any tuples are processed.
	 * 
	 * @param context
	 *            OperatorContext for this operator.
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	@Override
	public synchronized void initialize(OperatorContext context) throws Exception
	{
		// Must call super.initialize(context) to correctly setup an operator.
		super.initialize(context);
		Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " initializing in PE: "
				+ context.getPE().getPEId() + " in Job: " + context.getPE().getJobId());
	
		String propFile = getPropertiesFile();

		if (propFile != null)
		{
			twitterAuthProperties.load(new FileReader(propFile));

			twitterAuthProperties.putAll(properties);
			twitterAuthProperties = getProperties(twitterAuthProperties);
		}
		if (consumerKey == null || consumerKey.isEmpty())
			throw new Exception("Twitter consumerKey property must be specified in twitter propertyfile.");

		/*
		 * // only for test 
		 * System.out.println("Properties file: " + propertiesFile); 
		 * System.out.println("consumerKey: " + consumerKey);
		 * System.out.println("consumerSecret: " + consumerSecret);
		 * System.out.println("accessToken: " + accessToken);
		 * System.out.println("accessTokenSecret: " + accessTokenSecret);
		 */
		sendDirectMessage = new SendDirectMessage();
		sendDirectMessage.initialize(consumerKey, consumerSecret, accessToken, accessTokenSecret);

	}

	/**
	 * get absolute file path
	 * @param filePath
	 * @return absolute file path
	 */
	
	public String getAbsoluteFilePath(String filePath)
	{
		File file = new File(filePath);

		// if the properties file is relative, the path is relative to the
		// application directory
		if (!file.isAbsolute())
		{
			filePath = getOperatorContext().getPE().getApplicationDirectory().getAbsolutePath() + "/" + filePath;
		}
		return filePath;
	}

	/**
	 * get properties file
	 * @return propertiesFile
	 */
	public String getPropertiesFile()
	{
		Logger.getLogger(this.getClass()).trace("Properties file: " + propertiesFile);

		if (propertiesFile == null)
			return null;
		propertiesFile = getAbsoluteFilePath(propertiesFile);
		return propertiesFile;
	}

	/**
	 * getProperties from file and set the values in consumerKey,
	 * consumerSecret, accessToken, accessTokenSecret
	 * @param props
	 * @return
	 */
	private Properties getProperties(Properties props)
	{
		final String consumerKeyePropertyName = "consumerKey";
		final String consumerSecretPropertyName = "consumerSecret";
		final String accessTokenProtocolPropertyName = "accessToken";
		final String accessTokenSecretProtocolPropertyName = "accessTokenSecret";
		consumerKey = props.getProperty(consumerKeyePropertyName);
		consumerSecret = props.getProperty(consumerSecretPropertyName);
		accessToken = props.getProperty(accessTokenProtocolPropertyName);
		accessTokenSecret = props.getProperty(accessTokenSecretProtocolPropertyName);
		return props;
	}

	@Parameter(optional = false, description = "Properties file containing Twitter properties.  Properties file is recommended to be stored in the etc directory.  If a relative path is specified, the path is relative to the application directory.")
	public void setPropertiesFile(String value)
	{
		this.propertiesFile = value;
	}

	/**
	 * Notification that initialization is complete and all input and output
	 * ports are connected and ready to receive and submit tuples.
	 * 
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	@Override
	public synchronized void allPortsReady() throws Exception
	{
		// This method is commonly used by source operators.
		// Operators that process incoming tuples generally do not need this
		// notification.
		OperatorContext context = getOperatorContext();
		Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " all ports are ready in PE: "
				+ context.getPE().getPEId() + " in Job: " + context.getPE().getJobId());

	}

	/**
	 * Process an incoming tuple that arrived on the specified port.
	 * <P>
	 * Copy the incoming tuple to a new output tuple and submit to the output
	 * port.
	 * </P>
	 * 
	 * @param inputStream
	 *            Port the tuple is arriving on.
	 * @param tuple
	 *            Object representing the incoming tuple.
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	@Override
	public final void process(StreamingInput<Tuple> inputStream, Tuple tuple) throws Exception
	{
		int attributeCount = tuple.getStreamSchema().getAttributeCount();

		if (attributeCount < 2)
		{
			throw new Exception("Twitter recipient and message must be specified.");
		}

		String recipient = null;
		recipient = tuple.getString(0);

		String message = null;
		message = tuple.getString(1);

		if (recipient == null || recipient.isEmpty())
			throw new Exception("Twitter recipient property must be specified.");

		if (message == null || message.isEmpty())
			throw new Exception("Twitter message property must be specified.");

		// System.out.println("process inputStream: recipient : " + recipient +
		// " message : " + message);

		String result = "";
		try
		{
			result = sendDirectMessage.sendMessage(recipient, message);
			System.out.println("Result : " + result);
		} catch (Exception e)
		{
			Logger.getLogger(this.getClass()).trace("Exception : " + e.getMessage());
		}

	}

	/**
	 * Process an incoming punctuation that arrived on the specified port.
	 * 
	 * @param stream
	 *            Port the punctuation is arriving on.
	 * @param mark
	 *            The punctuation mark
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	@Override
	public void processPunctuation(StreamingInput<Tuple> stream, Punctuation mark) throws Exception
	{
		// For window markers, punctuate all output ports
		super.processPunctuation(stream, mark);
	}

	/**
	 * Shutdown this operator.
	 * 
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	public synchronized void shutdown() throws Exception
	{
		OperatorContext context = getOperatorContext();
		Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " shutting down in PE: "
				+ context.getPE().getPEId() + " in Job: " + context.getPE().getJobId());
		sendDirectMessage.disconnect();
		// Must call super.shutdown()
		super.shutdown();
	}
}
